# -*- coding: utf-8 -*-
"""ninibo1127

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1zxr-BSuHIRDOyN7QioA4lsa5uSHmm0o9
"""

import ccxt

# bitbankの取引所インスタンスを作成
bitbank = ccxt.bitbank()

try:
    # ロードマーケット情報
    bitbank.load_markets()

    # BTC/JPYペアの情報から最低取引数量を取得
    # 'limits'->'amount'->'min' のパスで取得できることが多い
    # 取引所によってはこの構造が異なる場合があります
    min_amount = bitbank.markets['BTC/JPY']['limits']['amount']['min']

    print(f"bitbank (BTC/JPY) の最低取引数量は {min_amount} BTC です。")

except ccxt.base.errors.ExchangeError as e:
    print(f"取引所エラーが発生しました: {e}")
except KeyError:
    print("必要な情報 (最低取引数量) が取引所情報に見つかりませんでした。")
    print("bitbankのAPIドキュメントを確認してください。")
except Exception as e:
    print(f"エラーが発生しました: {e}")

from dotenv import load_dotenv
import os

load_dotenv(dotenv_path='config.env')  # ← 変更後のファイル名に合わせてるよ

api_key = os.getenv("API_KEY")
secret_key = os.getenv("SECRET_KEY")

print("API_KEY:", api_key)
print("SECRET_KEY:", secret_key)

import ccxt # ccxtをインポート
import pandas as pd
import time
import os
import datetime # datetimeモジュールを追加
import pytz # タイムゾーンを扱うためのライブラリを追加

# 日本標準時 (JST) のタイムゾーンオブジェクトを作成
JST = pytz.timezone('Asia/Tokyo')

# === 1. 取引所への接続 ===
def connect_to_bitbank():
    """bitbankに接続します"""
    try:
        # Google ColabのシークレットからAPIキーを取得
        # 左側の鍵アイコンをクリックして、BITBANK_API_KEYとBITBANK_SECRET_KEYを設定してください。
        # os.environ.get() または userdata.get() を使用できます
        api_key = os.environ.get('BITBANK_API_KEY')
        secret_key = os.environ.get('BITBANK_SECRET_KEY')

        # デバッグ用: 取得したキーの一部を表示 (セキュリティのため全体は表示しない)
        print(f"DEBUG: API Key (partial): {api_key[:4]}...{api_key[-4:]}" if api_key else "DEBUG: API Key: None")
        print(f"DEBUG: Secret Key (partial): {secret_key[:4]}...{secret_key[-4:]}" if secret_key else "DEBUG: Secret Key: None")


        if not api_key or not secret_key:
            print("エラー：Google ColabのシークレットにAPIキーが設定されていません。")
            print("左側の鍵アイコンをクリックして、BITBANK_API_KEYとBITBANK_SECRET_KEYを設定してください。")
            return None

        # ccxtを使ってbitbankに接続
        exchange = ccxt.bitbank({
            'apiKey': api_key,
            'secret': secret_key,
        })
        print("bitbankにccxtで接続しました。")
        return exchange

    except Exception as e:
        print(f"bitbankへの接続中にエラーが発生しました: {e}")
        return None

# === 2. 価格データの取得 ===
def get_ohlcv(exchange, pair='BTC/JPY', timeframe='1m', limit=100):
    """
    指定した通貨ペアのOHLCVデータを取得します。(ccxt使用)
    Args:
        exchange: ccxtの取引所オブジェクト
        pair (str): 通貨ペア (例: 'BTC/JPY')
        timeframe (str): ローソク足の時間枠 (例: '1m', '5m', '15m', '1h', '1d')
        limit (int): 取得するローソク足の最大数
    Returns:
        pandas.DataFrame: OHLCVデータを含むDataFrame。エラーが発生した場合はNone。
    """
    try:
        # ccxtのfetch_ohlcvメソッドを使用
        # bitbankはtimeframeに'1min', '5min'などではなく'1m', '5m'などを使用
        ohlcv_data = exchange.fetch_ohlcv(pair, timeframe, limit=limit)

        if ohlcv_data:
            # データをDataFrameに変換
            df = pd.DataFrame(ohlcv_data, columns=['timestamp', 'open', 'high', 'low', 'close', 'volume'])
            df['timestamp'] = pd.to_datetime(df['timestamp'], unit='ms')
            df = df.set_index('timestamp')
            return df
        else:
            print(f"{pair} のOHLCVデータを取得できませんでした。")
            return None

    except Exception as e:
        print(f"OHLCVデータの取得中にエラーが発生しました: {e}")
        return None

# === 3. 売買シグナルの判定 ===
def generate_signals(df):
    """
    価格データに基づいて売買シグナルを生成します。
    ここでは簡単な移動平均クロスオーバー戦略を例とします。
    Args:
        df (pandas.DataFrame): OHLCVデータを含むDataFrame
    Returns:
        str or None: 'buy', 'sell', または None
    """
    if df is None or len(df) < 20: # 簡単な例として20期間の移動平均を使用
        return None

    # 短期移動平均線と長期移動平均線を計算
    df['short_mavg'] = df['close'].rolling(window=5).mean() # 例: 5期間
    df['long_mavg'] = df['close'].rolling(window=20).mean() # 例: 20期間

    # 最新のデータポイントを取得
    latest_data = df.iloc[-1]
    previous_data = df.iloc[-2]

    signal = None

    # ゴールデンクロス（短期移動平均線が長期移動平均線を上抜ける）で買いシグナル
    if previous_data['short_mavg'] <= previous_data['long_mavg'] and latest_data['short_mavg'] > latest_data['long_mavg']:
        signal = 'buy'
        print("買いシグナルが発生しました。")

    # デッドクロス（短期移動平均線が長期移動平均線を下抜ける）で売りシグナル
    elif previous_data['short_mavg'] >= previous_data['long_mavg'] and latest_data['short_mavg'] < latest_data['long_mavg']:
        signal = 'sell'
        print("売りシグナルが発生しました。")

    return signal

# === 4. 注文の実行 ===
def execute_order(exchange, pair, order_type, amount, price=None):
    """
    bitbankに注文を出します。(ccxt使用)
    Args:
        exchange: ccxtの取引所オブジェクト
        pair (str): 通貨ペア (例: 'BTC/JPY')
        order_type (str): 注文タイプ ('buy' or 'sell')
        amount (float): 注文数量
        price (float, optional): 指値注文の場合の価格。デフォルトはNone（成行注文）。
    Returns:
        dict or None: 注文結果の辞書。エラーが発生した場合はNone。
    """
    try:
        # ccxtのcreate_orderメソッドを使用
        if order_type == 'buy':
            type = 'limit' if price else 'market'
            order = exchange.create_order(pair, type, 'buy', amount, price)
            print(f"{type} 買い注文を発注しました: {amount} {pair.split('/')[0]} {'@ ' + str(price) if price else ''}")
        elif order_type == 'sell':
            type = 'limit' if price else 'market'
            order = exchange.create_order(pair, type, 'sell', amount, price)
            print(f"{type} 売り注文を発注しました: {amount} {pair.split('/')[0]} {'@ ' + str(price) if price else ''}")
        else:
            print(f"無効な注文タイプです: {order_type}")
            return None

        if order:
            print("注文成功:", order)
            return order
        else:
            print("注文に失敗しました:", order)
            return None

    except Exception as e:
        print(f"注文実行中にエラーが発生しました: {e}")
        return None

# === 5. メインループ（Botの実行部分） ===
def run_bot(pair='BTC/JPY', interval_seconds=60):
    """
    自動売買Botのメイン実行ループです。(ccxt使用)
    Args:
        pair (str): 取引する通貨ペア (ccxt形式、例: 'BTC/JPY')
        interval_seconds (int): データ取得とロジック実行の間隔（秒）
    """
    # ccxt形式の通貨ペアに変換 (既に引数でccxt形式を期待するように修正)
    # pair = pair.upper().replace('_', '/')

    exchange = connect_to_bitbank()
    if not exchange:
        print("API接続に失敗したためBotを停止します。")
        return

    print(f"Botを {pair} で実行します。データ取得間隔: {interval_seconds}秒")

    # Botの状態を管理する変数（例：現在保有しているポジション）
    # 簡単な例として、常にノーポジションから始める
    current_position = None # 'long' (買いポジション), 'short' (売りポジション), None (ノーポジション)
    # 実際の取引では、資金管理や建玉管理が必要です。

    while True:
        try:
            # ループが実行されているか確認するためのprint文
            print("Bot loop iteration started.")

            # 現在の日付と時刻を取得 (UTC)
            now_utc = datetime.datetime.now(datetime.timezone.utc)
            print(f"DEBUG: UTC時刻 (取得直後): {now_utc.strftime('%Y-%m-%d %H:%M:%S.%f %Z')}")


            # JSTに変換
            now_jst = now_utc.astimezone(JST)
            print(f"DEBUG: JST時刻 (変換後): {now_jst.strftime('%Y-%m-%d %H:%M:%S.%f %Z')}")


            weekday = now_jst.weekday() # 月曜日が0、日曜日が6

            # 土曜日 (5) または日曜日 (6) でない場合はスキップ
            if weekday < 5:
                # ミリ秒まで表示
                print(f"現在時刻 (JST): {now_jst.strftime('%Y-%m-%d %H:%M:%S.%f')} - 平日なので取引をスキップします。")
                time.sleep(interval_seconds)
                continue # ループの先頭に戻る

            # ミリ秒まで表示
            print(f"現在時刻 (JST): {now_jst.strftime('%Y-%m-%d %H:%M:%S.%f')} - 週末なので取引を実行します。")

            # 2. 価格データの取得 (ccxt形式のpairとtimeframeを使用)
            # ccxtでは時間枠は'1m', '5m'など、通貨ペアは'BTC/JPY'の形式が一般的
            ohlcv_df = get_ohlcv(exchange, pair, timeframe='1h', limit=25) # 例: 1分足データを25本取得

            if ohlcv_df is not None and not ohlcv_df.empty:
                # 3. 売買シグナルの判定
                signal = generate_signals(ohlcv_df)

                # 4. 注文の実行
                if signal == 'buy' and current_position is None:
                    # 買いシグナルが出て、ノーポジションの場合に買い注文
                    # 例として、決められた数量を成行買い
                    buy_amount = 0.001 # 例: 0.001 BTC
                    # ccxt形式のpairを渡す
                    order_result = execute_order(exchange, pair, 'buy', buy_amount, price=None) # 成行買い
                    if order_result:
                         current_position = 'long' # ポジションを持ったと仮定 (実際の約定確認が必要)

                elif signal == 'sell' and current_position == 'long':
                    # 売りシグナルが出て、買いポジションを持っている場合に売り注文（手仕舞い）
                    # 例として、保有数量を成行売り
                    # ここでは簡単のため、買い注文と同じ数量を売ると仮定 (実際の保有数量を取得する必要あり)
                    sell_amount = 0.001 # 例: 0.001 BTC
                     # ccxt形式のpairを渡す
                    order_result = execute_order(exchange, pair, 'sell', sell_amount, price=None) # 成行売り
                    if order_result:
                         current_position = None # ポジションを解消したと仮定 (実際の約定確認が必要)

                # ロジックの実行状況を表示
                print(f"現在のシグナル: {signal}, 現在のポジション: {current_position}")

            else:
                print("データ取得に失敗したため、次のループに進みます。")

        except Exception as e:
            print(f"Bot実行中にエラーが発生しました: {e}")

        # 指定された間隔で待機
        print(f"次回の実行まで {interval_seconds}秒待機します...")
        time.sleep(interval_seconds)

# Botを実行 (必要に応じてコメントを外して実行)
if __name__ == "__main__":
    run_bot('BTC/JPY', 3600) # BTC/JPYペアで3600秒間隔で実行 (通貨ペアをccxt形式に修正)

import os

# ① 環境変数をファイルから読み込む関数
def load_env_from_file(filename):
    with open(filename) as f:
        for line in f:
            if '=' in line:
                key, value = line.strip().split('=', 1)
                os.environ[key] = value

# ② 読み込むファイルを指定
load_env_from_file("config.env")  # または "keys.log"

# ③ 読み込んだ環境変数を使う
api_key = os.getenv("API_KEY")
secret_key = os.getenv("SECRET_KEY")

"""# Task
CONOHA VPS上で、現在Colabで動作しているBotを動作させる。

## Conoha vpsのセットアップ

### Subtask:
CONOHA VPSを契約し、OS（例: Ubuntu）をインストールし、SSHで接続できるようにします。

## 必要なソフトウェアのインストール

### Subtask:
VPSにPython、pip、そしてBotが必要とするライブラリ（ccxt, pandas, pytz）をインストールします。

## Botコードの転送

### Subtask:
現在のColab notebookからBotのPythonコードをVPSに転送します。

## Apiキーの設定

### Subtask:
Colabのシークレットマネージャーではなく、VPS上で安全な方法（環境変数など）でAPIキーを設定します。

## Botの実行

### Subtask:
VPS上でBotのPythonスクリプトを実行します。永続的に実行するために、`screen`や`tmux`、またはsystemdなどのツールを使用することを検討します。

## 監視とログ

### Subtask:
Botが正常に動作しているか監視し、問題発生時にデバッグできるようログを設定します。

## Summary:

### Data Analysis Key Findings

* The entire process of migrating the bot from Colab to CONOHA VPS involves several steps that require manual interaction with the VPS environment, including setting up the VPS, installing software, transferring code, configuring API keys, executing the bot, and monitoring/logging.
* The current execution environment (Jupyter Notebook/Colab) does not support the necessary operations, such as SSH connections, remote file system interaction, and executing commands directly on the VPS.
* Consequently, none of the sub-tasks could be completed programmatically within the notebook environment.

### Insights or Next Steps

* The migration process requires direct access to and interaction with the CONOHA VPS via SSH.
* The user needs to perform the steps manually or use tools outside the Colab environment to complete the bot migration.
"""