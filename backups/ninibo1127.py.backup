# python 3.14ç’°å¢ƒã§å‹•ä½œç¢ºèªæ¸ˆã¿ (ä»®æƒ³ç’°å¢ƒvenv314ã‚’ä½¿ç”¨)
# === å¿…è¦ãªãƒ©ã‚¤ãƒ–ãƒ©ãƒªã‚’1å›ãšã¤ã‚¤ãƒ³ãƒãƒ¼ãƒˆï¼ˆå¿ƒè‡“éƒ¨ã®æº–å‚™ï¼‰ ===

# ccxt ãŒã‚¤ãƒ³ã‚¹ãƒˆãƒ¼ãƒ«ã•ã‚Œã¦ã„ãªã„ç’°å¢ƒã§ã‚‚ãƒ•ã‚¡ã‚¤ãƒ«ãŒèª­ã¿è¾¼ã‚ã‚‹ã‚ˆã†ã€ãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯ã®ã‚¹ã‚¿ãƒ–ã‚’ç”¨æ„ã—ã¾ã™ã€‚
try:
    import ccxt
except Exception:
    # æœ€ä½é™ã®ã‚¤ãƒ³ã‚¿ãƒ¼ãƒ•ã‚§ãƒ¼ã‚¹ã‚’æŒã¤ã‚¹ã‚¿ãƒ–å®Ÿè£…
    class AuthenticationError(Exception):
        pass

    class BitbankStub:
        def __init__(self, config=None):
            self.apiKey = (config or {}).get('apiKey')
            self.secret = (config or {}).get('secret')

        def fetch_balance(self):
            # ãƒ†ã‚¹ãƒˆç”¨ã®ãƒ€ãƒŸãƒ¼æ®‹é«˜
            return {'total': {'JPY': 0.0, 'BTC': 0.0}}

        def fetch_ticker(self, pair):
            # ãƒ†ã‚¹ãƒˆç”¨ã®ãƒ€ãƒŸãƒ¼ä¾¡æ ¼
            return {'last': 0.0}

        def fetch_ohlcv(self, pair, timeframe='1h', limit=250):
            # ç©ºã®ãƒ‡ãƒ¼ã‚¿ã‚’è¿”ã—ã¦å‘¼ã³å‡ºã—å´ã§å®‰å…¨ã«æ‰±ãˆã‚‹ã‚ˆã†ã«ã™ã‚‹
            return []

        def create_order(self, pair, type_, side, amount, price=None):
            # ãƒ€ãƒŸãƒ¼æ³¨æ–‡ãƒ¬ã‚¹ãƒãƒ³ã‚¹
            return {'id': 'stub_order', 'pair': pair, 'type': type_, 'side': side, 'amount': amount, 'price': price}

    class _CCXTModule:
        AuthenticationError = AuthenticationError
        def bitbank(self, config=None):
            return BitbankStub(config)

    ccxt = _CCXTModule()

# å¾Œç¶šã‚³ãƒ¼ãƒ‰ãŒä½¿ã†ãŸã‚ã«åå‰ã‚’æƒãˆã‚‹
# ccxt ã‚’ç›´æ¥å‚ç…§ã™ã‚‹ä»£ã‚ã‚Šã«ã€ã“ã®ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«å†…ã§ä½¿ã†å…±é€šã®ä¾‹å¤–å‚ç…§ã‚’ä½œæˆã—ã¾ã™ã€‚
# å®Ÿç’°å¢ƒã§ã¯ ccxt.AuthenticationError ãŒå­˜åœ¨ã—ã¾ã™ã€‚ã‚¹ã‚¿ãƒ–ç’°å¢ƒã§ã¯ä¸Šã§å®šç¾©ã—ãŸã‚‚ã®ãŒå…¥ã‚Šã¾ã™ã€‚
AuthenticationError = getattr(ccxt, 'AuthenticationError', Exception)

# äº’æ›æ€§å¯¾ç­–: ä¸€éƒ¨ã®ã‚³ãƒ¼ãƒ‰ã‚„ãƒ©ã‚¤ãƒ–ãƒ©ãƒªã¯ ccxt.base.errors.AuthenticationError ã‚’å‚ç…§ã™ã‚‹
# ã“ã¨ãŒã‚ã‚‹ãŸã‚ã€ccxt.base.errors.AuthenticationError ãŒå­˜åœ¨ã—ãªã„å ´åˆã¯è£œå®Œã—ã¦ãŠãã¾ã™ã€‚
try:
    base_obj = getattr(ccxt, 'base', None)
    if base_obj is None or not hasattr(base_obj, 'errors'):
        class _BaseErrors:
            pass
        setattr(_BaseErrors, 'AuthenticationError', getattr(ccxt, 'AuthenticationError', Exception))

        class _Base:
            pass
        setattr(_Base, 'errors', _BaseErrors)
        setattr(ccxt, 'base', _Base)
except Exception:
    # ä¿é™º: ä½•ã‹å•é¡ŒãŒã‚ã‚Œã°ç„¡è¦–ã—ã¦æ—¢å­˜ã® AuthenticationError ã‚’ä½¿ã†
    pass

# funds ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ãŒå­˜åœ¨ã—ã¦ã‚‚ã€å¤–éƒ¨ã® FundManager ãŒã“ã®ã‚¹ã‚¯ãƒªãƒ—ãƒˆã®æœŸå¾…ã™ã‚‹
# ãƒ¡ã‚½ãƒƒãƒ‰ (available_fund, place_order, add_funds) ã‚’æŒãŸãªã„å ´åˆãŒã‚ã‚‹ãŸã‚ã€
# äº’æ›æ€§ãƒã‚§ãƒƒã‚¯ã‚’ã—ã¦ä¸ä¸€è‡´ãªã‚‰å†…éƒ¨ã‚¹ã‚¿ãƒ–ã‚’ä½¿ã†ã‚ˆã†ã«ã—ã¾ã™ã€‚
def _make_internal_fund_manager_class():
    class FundManagerStub:
        def __init__(self, exchange=None, initial_fund=0):
            self.exchange = exchange
            self._available = float(initial_fund)

        def available_fund(self):
            return float(self._available)

        def place_order(self, cost):
            # æ®‹é«˜ã‹ã‚‰å·®ã—å¼•ãç°¡æ˜“å®Ÿè£…ï¼ˆãƒ†ã‚¹ãƒˆç”¨ï¼‰
            try:
                self._available = float(self._available) - float(cost)
            except Exception:
                pass

        def add_funds(self, amount):
            # å°‘é¡ãšã¤å…¥é‡‘ã™ã‚‹æ©Ÿèƒ½ï¼ˆä¾‹: æ¯æ™‚é–“å®šé¡å…¥é‡‘ãªã©ï¼‰
            try:
                self._available = float(self._available) + float(amount)
            except Exception:
                pass

    return FundManagerStub

_InternalFundManager = _make_internal_fund_manager_class()

try:
    from funds import FundManager as _ImportedFundManager  # type: ignore
    # ç°¡æ˜“çš„ãªäº’æ›æ€§ãƒã‚§ãƒƒã‚¯: ã‚¯ãƒ©ã‚¹ã«æƒ³å®šã™ã‚‹ãƒ¡ã‚½ãƒƒãƒ‰ãŒå­˜åœ¨ã™ã‚‹ã‹
    required = ('available_fund', 'place_order', 'add_funds')
    if all(hasattr(_ImportedFundManager, name) for name in required):
        FundManager = _ImportedFundManager
    else:
        # äº’æ›æ€§ãªã— â†’ å†…éƒ¨ã‚¹ã‚¿ãƒ–ã‚’åˆ©ç”¨
        FundManager = _InternalFundManager
except Exception:
    # ã‚¤ãƒ³ãƒãƒ¼ãƒˆå¤±æ•—æ™‚ã¯å†…éƒ¨ã‚¹ã‚¿ãƒ–ã‚’åˆ©ç”¨
    FundManager = _InternalFundManager

fund_manager = FundManager(initial_fund=0.0)


def _adapt_fund_manager_instance(fm):
    """
    Wrap an external FundManager instance so it exposes the small API
    this script expects: available_fund(), place_order(cost), add_funds(amount).
    If the passed object already has these methods, return it unchanged.
    Otherwise return an adapter that attempts to call the underlying
    implementation when possible and falls back to an internal counter.
    """
    # If fm already implements the required API, return it
    if all(hasattr(fm, name) for name in ('available_fund', 'place_order', 'add_funds')):
        return fm

    class _Adapter:
        def __init__(self, underlying, initial=0.0):
            self._u = underlying
            # internal fallback balance
            try:
                self._available = float(initial)
            except Exception:
                self._available = 0.0

        def available_fund(self):
            # try a variety of possible backing attributes/methods
            try:
                if hasattr(self._u, 'available_fund'):
                    return float(self._u.available_fund())
                if hasattr(self._u, 'total_fund'):
                    val = getattr(self._u, 'total_fund')
                    return float(val() if callable(val) else val)
                if hasattr(self._u, 'get_total'):
                    return float(self._u.get_total())
                if hasattr(self._u, 'balance'):
                    b = getattr(self._u, 'balance')
                    if callable(b):
                        b = b()
                    # try common shapes
                    if isinstance(b, dict):
                        # try JPY key
                        try:
                            return float(b.get('JPY') or b.get('jpy') or 0.0)
                        except Exception:
                            return float(0.0)
                    try:
                        return float(b)
                    except Exception:
                        pass
            except Exception:
                pass
            return float(self._available)

        def place_order(self, cost):
            try:
                if hasattr(self._u, 'place_order'):
                    return self._u.place_order(cost)
            except Exception:
                # fall through to internal handling
                pass
            try:
                self._available = float(self._available) - float(cost)
            except Exception:
                pass

        def add_funds(self, amount):
            try:
                if hasattr(self._u, 'add_funds'):
                    return self._u.add_funds(amount)
            except Exception:
                pass
            try:
                self._available = float(self._available) + float(amount)
            except Exception:
                pass

    return _Adapter(fm, initial=getattr(fm, '_available', 0.0) if fm is not None else 0.0)

import os
import time
import datetime
import math
try:
    import pandas as pd
except Exception:
    # Minimal pandas-like stub to avoid import errors and provide the small API used in this script.
    # NOTE: This is a lightweight compatibility shim for parsing/testing and does NOT replace real pandas.
    class Series:
        def __init__(self, values):
            self.values = list(values) if values is not None else []
            self._window = None

        def rolling(self, window):
            self._window = int(window)
            return self

        def mean(self):
            vals = self.values
            w = self._window or 1
            if not vals:
                return []
            res = []
            for i in range(len(vals)):
                if i + 1 < w:
                    res.append(None)
                else:
                    window_vals = [v for v in vals[i + 1 - w:i + 1] if v is not None]
                    res.append(sum(window_vals) / len(window_vals) if window_vals else None)
            return res

        def __iter__(self):
            return iter(self.values)

    class Row:
        def __init__(self, data):
            self._data = data or {}

        def __getitem__(self, key):
            return self._data.get(key)

        def __getattr__(self, name):
            if name in self._data:
                return self._data[name]
            raise AttributeError(name)

    class DataFrame:
        def __init__(self, data=None, columns=None):
            # data: list of lists (rows) or list of dicts
            self._columns = list(columns) if columns else []
            self._rows = []
            if data:
                if self._columns and all(isinstance(r, (list, tuple)) for r in data):
                    for row in data:
                        self._rows.append({c: v for c, v in zip(self._columns, row)})
                elif all(isinstance(r, dict) for r in data):
                    self._rows = [dict(r) for r in data]
                    if not self._columns:
                        cols = set()
                        for r in self._rows:
                            cols.update(r.keys())
                        self._columns = list(cols)
                else:
                    # fallback: single column
                    col = self._columns[0] if self._columns else "data"
                    for r in data:
                        self._rows.append({col: r})
            self.index = None

        def __len__(self):
            return len(self._rows)

        def __getitem__(self, key):
            if isinstance(key, str):
                vals = [row.get(key) for row in self._rows]
                return Series(vals)
            raise KeyError(key)

        def __setitem__(self, key, value):
            # value can be Series or iterable; align by index
            vals = list(value) if hasattr(value, '__iter__') and not isinstance(value, (str, bytes)) else [value] * len(self._rows)
            if not self._rows and vals:
                for v in vals:
                    self._rows.append({key: v})
            else:
                for i, v in enumerate(vals):
                    if i < len(self._rows):
                        self._rows[i][key] = v
                    else:
                        self._rows.append({key: v})
            if key not in self._columns:
                self._columns.append(key)

        @property
        def iloc(self):
            class _Loc:
                def __init__(self, rows):
                    self._rows = rows

                def __getitem__(self, idx):
                    return Row(self._rows[idx])
            return _Loc(self._rows)

        def set_index(self, key):
            self.index = key
            return self

    def to_datetime(values, unit='ms'):
        out = []
        for v in values:
            try:
                if v is None:
                    out.append(None)
                    continue
                if unit == 'ms':
                    ts = float(v) / 1000.0
                else:
                    ts = float(v)
                out.append(datetime.datetime.fromtimestamp(ts))
            except Exception:
                out.append(None)
        return out

    import types
    pd = types.SimpleNamespace(DataFrame=DataFrame, to_datetime=to_datetime)

from zoneinfo import ZoneInfo  # æ¨™æº–ãƒ©ã‚¤ãƒ–ãƒ©ãƒªã®ã‚¿ã‚¤ãƒ ã‚¾ãƒ¼ãƒ³å‡¦ç†
# dotenv ãŒã‚¤ãƒ³ã‚¹ãƒˆãƒ¼ãƒ«ã•ã‚Œã¦ã„ãªã„ç’°å¢ƒã§ã‚‚ãƒ•ã‚¡ã‚¤ãƒ«ãŒèª­ã¿è¾¼ã‚ã‚‹ã‚ˆã†ã€ãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯ã®ã‚¹ã‚¿ãƒ–ã‚’ç”¨æ„ã—ã¾ã™ã€‚

try:
    from dotenv import load_dotenv  # type: ignore[reportMissingImports]
except Exception:
    # minimal stub for load_dotenv to allow .env loading when python-dotenv is not installed
    def load_dotenv(dotenv_path=None):
        """
        Very small implementation that reads KEY=VALUE lines from a file and sets os.environ entries.
        Returns True if a file was read, False otherwise.
        """
        if not dotenv_path or not os.path.exists(dotenv_path):
            return False
        try:
            with open(dotenv_path, 'r', encoding='utf-8') as f:
                for line in f:
                    line = line.strip()
                    if not line or line.startswith('#'):
                        continue
                    if '=' in line:
                        k, v = line.split('=', 1)
                        k = k.strip()
                        v = v.strip()
                        # strip optional surrounding quotes
                        if (v.startswith('"') and v.endswith('"')) or (v.startswith("'") and v.endswith("'")):
                            v = v[1:-1]
                        # do not overwrite existing environment variables
                        os.environ.setdefault(k, v)
            return True
        except Exception:
            return False


# === .envãƒ•ã‚¡ã‚¤ãƒ«ã®èª­ã¿è¾¼ã¿ï¼ˆåŒã˜ãƒ•ã‚©ãƒ«ãƒ€ã«ã‚ã‚‹å ´åˆï¼‰ ===
    # load .env once at startup so subsequent os.getenv() calls see values
    load_dotenv(dotenv_path='.env')

    # ã‚°ãƒ­ãƒ¼ãƒãƒ«ã«ä½¿ã† API ã‚­ãƒ¼ã‚’ä¸€åº¦ã ã‘èª­ã¿è¾¼ã‚€
    API_KEY = os.getenv("API_KEY")
    SECRET_KEY = os.getenv("SECRET_KEY")

    # æ—¥æœ¬æ¨™æº–æ™‚ (JST) ã®ã‚¿ã‚¤ãƒ ã‚¾ãƒ¼ãƒ³ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‚’ä½œæˆ
    JST = ZoneInfo('Asia/Tokyo')

# === ç’°å¢ƒå¤‰æ•°ã®å–å¾— ===
smtp_user = os.getenv("SMTP_USER")
smtp_password = os.getenv("SMTP_PASSWORD")
email_to = os.getenv("EMAIL_TO")
smtp_host = os.getenv("SMTP_HOST")  # ã‚­ãƒ¼åã‚’å–å¾—ã™ã‚‹å¤‰æ•°ã‚’ smtp_host ã«å¤‰æ›´
if smtp_host is None:  # ğŸ‘ˆ ä¿®æ­£ç®‡æ‰€ï¼ å–å¾—ã—ãŸå¤‰æ•° smtp_host ã‚’ãƒã‚§ãƒƒã‚¯
    raise ValueError("SMTP_HOST ãŒ .env ã«è¨­å®šã•ã‚Œã¦ã„ã¾ã›ã‚“")

subject = os.getenv("SUBJECT", "ğŸ“¬ é€šçŸ¥")

# === SMTP_PORT ã®å®‰å…¨ãªèª­ã¿è¾¼ã¿ ===
# ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆã‚’ 465 (SMTPS) ã«ã—ã¦ãŠãã¾ã™ã€‚ç’°å¢ƒå¤‰æ•°ãŒã‚ã‚Œã°ãã‚Œã‚’ä½¿ã„ã€æ•´æ•°å¤‰æ›ã«å¤±æ•—ã—ãŸã‚‰ 465 ã«ãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯ã—ã¾ã™ã€‚
port_str = os.getenv("SMTP_PORT", "465")
try:
    smtp_port = int(port_str)
except Exception:
    smtp_port = 465

# === ãƒ¡ãƒ¼ãƒ«é€ä¿¡é–¢æ•° ===
def send_notification(smtp_host, smtp_port, smtp_user, smtp_password, to, subject, body):
    from email.mime.text import MIMEText
    import smtplib

    msg = MIMEText(body)
    msg["Subject"] = subject
    msg["From"] = smtp_user
    msg["To"] = to

    # ç’°å¢ƒå¤‰æ•°ã¾ãŸã¯ãƒãƒ¼ãƒˆã«ã‚ˆã‚‹ SMTPS åˆ¤å®š
    use_ssl_env = os.getenv("SMTP_USE_SSL")
    if use_ssl_env is None:
        # æ˜ç¤ºæŒ‡å®šãŒãªã‘ã‚Œã°ãƒãƒ¼ãƒˆãŒ 465 ã®å ´åˆã¯ SSL ã‚’ä½¿ã†
        use_ssl = (int(smtp_port) == 465)
    else:
        use_ssl = str(use_ssl_env).lower() in ("1", "true", "yes", "on")

    try:
        if use_ssl:
            # SMTPS (implicit TLS)
            with smtplib.SMTP_SSL(smtp_host, smtp_port) as server:
                server.login(smtp_user, smtp_password)
                server.send_message(msg)
        else:
            # StartTLS ã‚’ä½¿ã†é€šå¸¸ã®æ¥ç¶š
            with smtplib.SMTP(smtp_host, smtp_port) as server:
                server.starttls()
                server.login(smtp_user, smtp_password)
                server.send_message(msg)

        print("âœ… ãƒ¡ãƒ¼ãƒ«é€ä¿¡æˆåŠŸ")
    except Exception as e:
        print(f"âŒ ãƒ¡ãƒ¼ãƒ«é€ä¿¡å¤±æ•—: {e}")


# å–å¼•æ‰€ã®è¨­å®šã‚’å–å¾—
exchange_name = os.getenv("EXCHANGE", "bitbank")


# === ãƒ¡ã‚¤ãƒ³å‡¦ç†é–‹å§‹ï¼ˆBotã®å¿ƒè‡“ãŒå‹•ãå‡ºã™ï¼‰ ===
if __name__ == "__main__":
    print("Botèµ·å‹•ä¸­...")
    # run_botã®å®šç¾©å¾Œã«å‘¼ã³å‡ºã™ã‚ˆã†ã«ç§»å‹•ã—ã¾ã—ãŸ

# 1. åˆæœŸè¨­å®šã¨èªè¨¼ (APIã‚­ãƒ¼ã®èª­ã¿è¾¼ã¿ã¯ã“ã“ã«ã‚ã‚Šã¾ã™)

# .envãƒ•ã‚¡ã‚¤ãƒ«ã‹ã‚‰APIã‚­ãƒ¼ã‚’èª­ã¿è¾¼ã¿ã¾ã™ï¼ˆconfig.envã‹ã‚‰çµ±åˆæ¸ˆã¿ï¼‰

 
# â€»æ³¨æ„: APIã‚­ãƒ¼èª­ã¿è¾¼ã¿ã¨ bitbank ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ã®ç›´æ¥ä½œæˆã¯
# connect_to_bitbank() ã«çµ±åˆã—ã¾ã—ãŸã€‚å…ƒã®ç›´æ¥ä½œæˆã‚³ãƒ¼ãƒ‰ã‚’å‰Šé™¤ã—ã¦ã„ã¾ã™ã€‚
# å¿…è¦ã§ã‚ã‚Œã°ã€ç’°å¢ƒå¤‰æ•°ã®ç¢ºèªã¯ connect_to_bitbank() å‘¼ã³å‡ºã—æ™‚ã«è¡Œã‚ã‚Œã¾ã™ã€‚

# æ—§æ¥ã®ç›´æ¥æ¥ç¶šãƒ†ã‚¹ãƒˆ/ç›£è¦–ãƒ«ãƒ¼ãƒ—ã¯å‰Šé™¤ã—ã¾ã—ãŸã€‚
# å–å¼•æ‰€æ¥ç¶šã¨ãƒ«ãƒ¼ãƒ—ã¯ connect_to_bitbank() ã¨ run_bot() ã«çµ±åˆã•ã‚Œã¦ã„ã¾ã™ã€‚


# ==========================================================
# ğŸ”‘ 2. ã‚°ãƒ­ãƒ¼ãƒãƒ«ã‚­ãƒ¼èª­ã¿è¾¼ã¿ã¨å®šç¾© (ä¿®æ­£ç‚¹: æœ€ä¸Šéƒ¨ã«ç§»å‹•)
# ==========================================================
#.env# config.envã‹ã‚‰APIã‚­ãƒ¼ã‚’èª­ã¿è¾¼ã¿ã¾ã™

load_dotenv(dotenv_path='.env') 
API_KEY = os.getenv("API_KEY") # ã‚°ãƒ­ãƒ¼ãƒãƒ«å®šæ•°ã¨ã—ã¦å®šç¾©
SECRET_KEY = os.getenv("SECRET_KEY") # ã‚°ãƒ­ãƒ¼ãƒãƒ«å®šæ•°ã¨ã—ã¦å®šç¾©

# æ—¥æœ¬æ¨™æº–æ™‚ (JST) ã®ã‚¿ã‚¤ãƒ ã‚¾ãƒ¼ãƒ³ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‚’ä½œæˆ
JST = ZoneInfo('Asia/Tokyo')

# --- dry-run / test stub support ---
# ç’°å¢ƒå¤‰æ•° DRY_RUN ãŒçœŸãªã‚‰å®Ÿéš›ã®ãƒãƒƒãƒˆãƒ¯ãƒ¼ã‚¯å‘¼ã³å‡ºã—ã‚„æ³¨æ–‡ã‚’è¡Œã‚ãªã„ã‚¹ã‚¿ãƒ–ã‚’ä½¿ã„ã¾ã™ã€‚
DRY_RUN = str(os.getenv('DRY_RUN', '0')).lower() in ('1', 'true', 'yes', 'on')
try:
    DRY_RUN_PRICE = float(os.getenv('DRY_RUN_PRICE', '5000000'))
except Exception:
    DRY_RUN_PRICE = 5000000.0

class ExchangeStub:
    """è»½é‡ãªå–å¼•æ‰€ã‚¹ã‚¿ãƒ–: dry-run ç”¨ã€‚å®Ÿãƒãƒƒãƒˆãƒ¯ãƒ¼ã‚¯å‘¼ã³å‡ºã—ã‚’è¡Œã„ã¾ã›ã‚“ã€‚"""
    def __init__(self, price=None):
        try:
            self._price = float(price) if price is not None else DRY_RUN_PRICE
        except Exception:
            self._price = DRY_RUN_PRICE

    def fetch_balance(self):
        return {'total': {'JPY': 100000.0, 'BTC': 0.0}}

    def fetch_ticker(self, pair):
        return {'last': self._price}

    def fetch_ohlcv(self, pair, timeframe='1h', limit=250):
        return []

    def create_order(self, pair, type_, side, amount, price=None):
        cost = None
        try:
            p = float(price) if price is not None else float(self._price)
            cost = float(amount) * p
        except Exception:
            cost = None
        return {'id': 'dry_order', 'pair': pair, 'type': type_, 'side': side, 'amount': amount, 'price': price, 'cost': cost}


# === 1. å–å¼•æ‰€ã¸ã®æ¥ç¶š ===
# ä¿®æ­£ç‚¹: ã‚°ãƒ­ãƒ¼ãƒãƒ«ã‚­ãƒ¼ã‚’ä½¿ç”¨ã™ã‚‹ãŸã‚å¼•æ•°ã‚’å‰Šé™¤ã—ã€å†—é•·ãªã‚³ãƒ¼ãƒ‰ã‚’å‰Šé™¤
def connect_to_bitbank():
    """bitbankã«æ¥ç¶šã—ã¾ã™ã€‚ã‚°ãƒ­ãƒ¼ãƒãƒ«ã§èª­ã¿è¾¼ã‚“ã APIã‚­ãƒ¼ã‚’ä½¿ç”¨ã—ã¾ã™ã€‚"""
    try:
        # dry-run ãŒæœ‰åŠ¹ãªå ´åˆã¯ãƒãƒƒãƒˆãƒ¯ãƒ¼ã‚¯ã‚’ä½¿ã‚ãªã„ã‚¹ã‚¿ãƒ–ã‚’è¿”ã™
        if str(os.getenv('DRY_RUN', '0')).lower() in ('1', 'true', 'yes', 'on'):
            price = os.getenv('DRY_RUN_PRICE')
            try:
                price = float(price) if price is not None else None
            except Exception:
                price = None
            print("ğŸ”§ DRY_RUN enabled â€” using ExchangeStub (no network calls).")
            return ExchangeStub(price)

        # API_KEYã¨SECRET_KEYã¯ãƒ•ã‚¡ã‚¤ãƒ«ã®æœ€ä¸Šéƒ¨ã§æ—¢ã«èª­ã¿è¾¼ã¾ã‚Œã¦ã„ã‚‹
        if not API_KEY or not SECRET_KEY:
            print("ã‚¨ãƒ©ãƒ¼ï¼šAPIã‚­ãƒ¼ã¾ãŸã¯ã‚·ãƒ¼ã‚¯ãƒ¬ãƒƒãƒˆã‚­ãƒ¼ãŒæœªå®šç¾©ã§ã™ã€‚config.envã‚’ç¢ºèªã—ã¦ãã ã•ã„ã€‚")
            return None

        # ccxtã‚’ä½¿ã£ã¦bitbankã«æ¥ç¶š
        exchange = ccxt.bitbank({
            'apiKey': API_KEY,
            'secret': SECRET_KEY,
        })
        print("âœ… bitbankã«ccxtã§èªè¨¼æ¥ç¶šã—ã¾ã—ãŸã€‚")
        return exchange

    except Exception as e:
        print(f"âŒ bitbankã¸ã®æ¥ç¶šä¸­ã«ã‚¨ãƒ©ãƒ¼ãŒç™ºç”Ÿã—ã¾ã—ãŸ: {e}")
        return None
     
        print("âœ… bitbankã«ccxtã§èªè¨¼æ¥ç¶šã—ã¾ã—ãŸã€‚")
        return exchange    

# === 2. ä¾¡æ ¼ãƒ‡ãƒ¼ã‚¿ã®å–å¾— ===
def get_ohlcv(exchange, pair='BTC/JPY', timeframe='1h', limit=250):
    """
    æŒ‡å®šã—ãŸé€šè²¨ãƒšã‚¢ã®OHLCVãƒ‡ãƒ¼ã‚¿ã‚’å–å¾—ã—ã¾ã™ã€‚(ccxtä½¿ç”¨)
    """
    try:
        ohlcv_data = exchange.fetch_ohlcv(pair, timeframe, limit=limit)

        if ohlcv_data:
            # ãƒ‡ãƒ¼ã‚¿ã‚’DataFrameã«å¤‰æ›
            df = pd.DataFrame(ohlcv_data, columns=['timestamp', 'open', 'high', 'low', 'close', 'volume'])
            df['timestamp'] = pd.to_datetime(df['timestamp'], unit='ms')
            df = df.set_index('timestamp')
            return df
        else:
            print(f"{pair} ã®OHLCVãƒ‡ãƒ¼ã‚¿ã‚’å–å¾—ã§ãã¾ã›ã‚“ã§ã—ãŸã€‚")
            return None

    except Exception as e:
        print(f"OHLCVãƒ‡ãƒ¼ã‚¿ã®å–å¾—ä¸­ã«ã‚¨ãƒ©ãƒ¼ãŒç™ºç”Ÿã—ã¾ã—ãŸ: {e}")
        return None

# === 3. å£²è²·ã‚·ã‚°ãƒŠãƒ«ã®åˆ¤å®šï¼ˆMA 25/75/200 + è²·ã„å¢—ã—ãƒ­ã‚¸ãƒƒã‚¯ï¼‰ ===
def generate_signals(df):
    """
    ä¾¡æ ¼ãƒ‡ãƒ¼ã‚¿ã«åŸºã¥ã„ã¦å£²è²·ã‚·ã‚°ãƒŠãƒ«ã‚’ç”Ÿæˆã—ã¾ã™ã€‚
    """
    # ãƒ‡ãƒ¼ã‚¿æ•°ãŒ200æœ¬å¿…è¦
    if df is None or len(df) < 200:
        # ã‚¨ãƒ©ãƒ¼ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã‚’æ”¹å–„
        print(f"âš ï¸ ãƒ‡ãƒ¼ã‚¿ãŒä¸è¶³ã—ã¦ã„ã¾ã™ã€‚æœ€ä½200æœ¬å¿…è¦ã§ã™ãŒã€{len(df) if df is not None else 0}æœ¬ã—ã‹ã‚ã‚Šã¾ã›ã‚“ã€‚")
        return None

    # çŸ­æœŸ25ã€ä¸­æœŸ75ã€é•·æœŸ200ã‚’è¿½åŠ 
    df['short_mavg'] = df['close'].rolling(window=25).mean()
    df['mid_mavg'] = df['close'].rolling(window=75).mean() # 75ã‚’midã«åç§°å¤‰æ›´
    df['long_mavg'] = df['close'].rolling(window=200).mean() # æ–°ã—ã„é•·æœŸMA

    latest_data = df.iloc[-1]
    previous_data = df.iloc[-2]

    signal = None
    message = None

    # ğŸ”‘ ãƒˆãƒ¬ãƒ³ãƒ‰ãƒ•ã‚£ãƒ«ã‚¿ãƒ¼
    is_uptrend = latest_data['mid_mavg'] > latest_data['long_mavg']
    mid_mavg_is_rising = latest_data['mid_mavg'] > previous_data['mid_mavg']

    # --- è²·ã„ã‚·ã‚°ãƒŠãƒ« 1ï¼šæ–°è¦ã‚¨ãƒ³ãƒˆãƒªãƒ¼ (ã‚´ãƒ¼ãƒ«ãƒ‡ãƒ³ã‚¯ãƒ­ã‚¹) ---
    if (previous_data['short_mavg'] <= previous_data['mid_mavg'] and
        latest_data['short_mavg'] > latest_data['mid_mavg'] and
        is_uptrend and mid_mavg_is_rising):
        signal = 'buy_entry' # æ–°è¦ã‚¨ãƒ³ãƒˆãƒªãƒ¼ã‚·ã‚°ãƒŠãƒ«
        message = "âœ… æ–°è¦ã‚¨ãƒ³ãƒˆãƒªãƒ¼ã‚·ã‚°ãƒŠãƒ« (GC 25/75ã€ãƒˆãƒ¬ãƒ³ãƒ‰ç¢ºèª) ãŒç™ºç”Ÿã—ã¾ã—ãŸã€‚"
        return signal, message

    # --- è²·ã„ã‚·ã‚°ãƒŠãƒ« 2ï¼šè²·ã„å¢—ã— (æŠ¼ã—ç›®) ---
    # æ³¨: GCå¾Œã€ãƒã‚¸ã‚·ãƒ§ãƒ³ä¿æœ‰ä¸­ã«ä¾¡æ ¼ãŒMA25ã‚’ä¸Šå›ã£ã¦ã„ã‚‹ï¼ˆæŠ¼ã—ç›®è²·ã„ï¼‰ã§ãƒˆãƒ¬ãƒ³ãƒ‰ä¸Šæ˜‡ä¸­
    elif latest_data['close'] > latest_data['short_mavg'] and is_uptrend:
        signal = 'buy_add' 
        message =  "ğŸ“ˆ è²·ã„å¢—ã—ã‚·ã‚°ãƒŠãƒ« (æŠ¼ã—ç›®è²·ã„) ãŒç™ºç”Ÿã—ã¾ã—ãŸã€‚"
        
    # --- å£²ã‚Šã‚·ã‚°ãƒŠãƒ«ï¼šå…¨æ±ºæ¸ˆ (ãƒˆãƒ¬ãƒ³ãƒ‰çµ‚äº†) ---
    # MA75ãŒMA200ã‚’ä¸‹å›ã£ãŸã€ã¾ãŸã¯MA75ãŒä¸‹å‘ãã«è»¢ã˜ãŸ
    elif not is_uptrend or latest_data['mid_mavg'] < previous_data['mid_mavg']:
        signal = 'sell_all'
        message = "âŒ å…¨æ±ºæ¸ˆã‚·ã‚°ãƒŠãƒ« (é•·æœŸãƒˆãƒ¬ãƒ³ãƒ‰çµ‚äº†/åè»¢) ãŒç™ºç”Ÿã—ã¾ã—ãŸã€‚"
    
    return signal, message


# === 4. æ³¨æ–‡ã®æ•´å½¢ ===

def log_order(action, pair, amount, price=None):
    """
  æ³¨æ–‡å†…å®¹ã‚’æ•´å½¢ã—ã¦ãƒ­ã‚°ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã‚’è¿”ã—ã¾ã™ã€‚
    """
    msg = f"{action}æ³¨æ–‡: {amount:.4f} {pair.split('/')[0]} {'@ ' + str(price) if price else 'ï¼ˆæˆè¡Œï¼‰'}"
    print(msg)
    return msg

# === 5. æ³¨æ–‡ã®å®Ÿè¡Œ ===

def execute_order(exchange, pair, order_type, amount, price=None):
    """
    Bitbankã«æ³¨æ–‡ã‚’å‡ºã—ã¾ã™ã€‚(ccxtä½¿ç”¨)
    """
    try:
        order = None

        # DRY_RUN ã®å ´åˆã¯å®Ÿéš›ã®æ³¨æ–‡ API å‘¼ã³å‡ºã—ã‚’è¡Œã‚ãšã€ã‚·ãƒŸãƒ¥ãƒ¬ãƒ¼ã‚·ãƒ§ãƒ³ã‚’è¿”ã™
        if str(os.getenv('DRY_RUN', '0')).lower() in ('1', 'true', 'yes', 'on'):
            # ä¾¡æ ¼ãŒæœªæŒ‡å®šãªã‚‰ DRY_RUN_PRICE ã‚’ä½¿ã†
            try:
                p = float(price) if price is not None else float(os.getenv('DRY_RUN_PRICE', str(DRY_RUN_PRICE)))
            except Exception:
                p = float(DRY_RUN_PRICE)
            simulated_cost = None
            try:
                simulated_cost = float(amount) * p
            except Exception:
                simulated_cost = None

            action_label = "ğŸ’° (DRY) è²·ã„" if order_type == 'buy' else "ğŸ’¸ (DRY) å£²ã‚Š"
            log_order(action_label, pair, amount, price)
            simulated = {'id': 'dry_order', 'amount': amount, 'cost': simulated_cost}
            print("â„¹ï¸ DRY_RUN: æ³¨æ–‡ã¯å®Ÿè¡Œã•ã‚Œã¾ã›ã‚“ã§ã—ãŸï¼ˆã‚·ãƒŸãƒ¥ãƒ¬ãƒ¼ã‚·ãƒ§ãƒ³ï¼‰")
            return simulated

        if order_type == 'buy':
            if price:
                # æŒ‡å®šä¾¡æ ¼ã§æˆè¡Œã§ã¯ãªãæŒ‡å€¤æ³¨æ–‡ã‚’å‡ºã™
                order = exchange.create_order(pair, 'limit', 'buy', amount, price)
            else:
                # ä¾¡æ ¼ãŒæŒ‡å®šã•ã‚Œã¦ã„ãªã‘ã‚Œã°æˆè¡Œæ³¨æ–‡
                order = exchange.create_order(pair, 'market', 'buy', amount)
            log_order("ğŸ’° è²·ã„", pair, amount, price)

        elif order_type == 'sell':
            if price:
                order = exchange.create_order(pair, 'limit', 'sell', amount, price)
            else:
                order = exchange.create_order(pair, 'market', 'sell', amount)
            log_order("ğŸ’¸ å£²ã‚Š", pair, amount, price)

        else:
            print(f"ç„¡åŠ¹ãªæ³¨æ–‡ã‚¿ã‚¤ãƒ—ã§ã™: {order_type}")
            return None

        if order and isinstance(order, dict) and 'id' in order:
            print("æ³¨æ–‡æˆåŠŸ:", order['id'])  # IDã®ã¿è¡¨ç¤ºã«ä¿®æ­£
            return order
        else:
            print("æ³¨æ–‡ã«å¤±æ•—ã—ã¾ã—ãŸ:", order)
            return None

    except Exception as e:
        import traceback
        traceback.print_exc()  # â† ã“ã‚Œã§ã‚¨ãƒ©ãƒ¼ã®è©³ç´°ãŒè¡¨ç¤ºã•ã‚Œã¾ã™

        print(f"âŒ æ³¨æ–‡å®Ÿè¡Œä¸­ã«ã‚¨ãƒ©ãƒ¼ãŒç™ºç”Ÿã—ã¾ã—ãŸ: {e}")
        return None

# === 6. ãƒ¡ã‚¤ãƒ³ãƒ«ãƒ¼ãƒ—ï¼ˆBotã®å®Ÿè¡Œéƒ¨åˆ†ï¼‰ ===
# ä¿®æ­£ç‚¹: ã‚°ãƒ­ãƒ¼ãƒãƒ«ã‚­ãƒ¼ã‚’ä½¿ç”¨ã™ã‚‹ãŸã‚ã€api_keyã¨secret_keyã®å¼•æ•°ã‚’å‰Šé™¤
def run_bot(exchange, fund_manager_instance): # ğŸ‘ˆ ã“ã®ã‚ˆã†ã«2ã¤ã®å¼•æ•°ã‚’å—ã‘å–ã‚‹
    # ... é–¢æ•°ã®æœ¬ä½“å†…ã§ã€pair ã‚„ interval_seconds ãŒå¿…è¦ãªã‚‰ã€
    # ... é–¢æ•°ã®æœ¬ä½“å†…ã§ã€é©åˆ‡ãªå€¤ã‚’å–å¾—ãƒ»å®šç¾©ã—ã¾ã™ã€‚
    pair = 'BTC/JPY'
    interval_seconds = 3600
   
    """
    è‡ªå‹•å£²è²·Botã®ãƒ¡ã‚¤ãƒ³å®Ÿè¡Œãƒ«ãƒ¼ãƒ—ã§ã™ã€‚(ccxtä½¿ç”¨)
    """
    # exchange ã¨ fund_manager_instance ã¯å¤–éƒ¨ã‹ã‚‰æ¸¡ã™ï¼ˆã¾ãŸã¯ä¸è¶³æ™‚ã«è£œã†ï¼‰
    if exchange is None:
        exchange = connect_to_bitbank()
    fund_manager = fund_manager_instance if fund_manager_instance is not None else FundManager(initial_fund=20000)
    if not exchange:
        print("APIæ¥ç¶šã«å¤±æ•—ã—ãŸãŸã‚Botã‚’åœæ­¢ã—ã¾ã™ã€‚")
        return

    print(f"Botã‚’ {pair} ã§å®Ÿè¡Œã—ã¾ã™ã€‚ãƒ‡ãƒ¼ã‚¿å–å¾—é–“éš”: {interval_seconds}ç§’ (1æ™‚é–“)")

    # --- ğŸ”‘ã€åˆæœŸè¨­å®šã€‘æ³¨æ–‡æ•°é‡ã®è¨ˆç®—ã¨æœ€ä½æ³¨æ–‡å˜ä½ã®ãƒã‚§ãƒƒã‚¯ ---
    
    # â€»ç¾åœ¨ã¯å®Ÿéš›ã®æ³¨æ–‡ã¯è¡Œã£ã¦ã„ãªã„ãŒã€å°†æ¥ã®å†é–‹ã«å‚™ãˆã¦è¨­å®šã¯æ®‹ã—ã¦ãŠã
    # 1. äºˆç®—ã¨æœ€ä½å–å¼•å˜ä½ã®è¨­å®š
    JAPANESE_YEN_BUDGET = 2000 #1å›ã®æ³¨æ–‡ã«ä½¿ã† æ—¥æœ¬å††ã®äºˆç®—: 2,000å††
    MIN_ORDER_BTC = 0.0001 # bitbank BTC/JPYã®æœ€ä½æ³¨æ–‡é‡ # bitbank BTC/JPYã®æœ€å°æ³¨æ–‡é‡ã€‚ccxtã®ä»•æ§˜ã¨ä¸€è‡´ã—ã¦ã„ã‚‹ã‹ç¢ºèªã™ã‚‹ã“ã¨ã€‚

    print(f"ğŸ’° 1å›ã‚ãŸã‚Šã®æ³¨æ–‡äºˆç®—: {JAPANESE_YEN_BUDGET} å††")
    print(f"ğŸ“‰ æœ€ä½æ³¨æ–‡æ•°é‡: {MIN_ORDER_BTC} BTC")

    # 2. æœ€æ–°ã®å¸‚å ´ä¾¡æ ¼ã‚’å–å¾—
    # ä¾¡æ ¼å–å¾—ã«æˆåŠŸã—ãŸã¨ä»®å®šã—ã€order_costã‚’è¨ˆç®—ï¼ˆä¸­ç•¥éƒ¨åˆ†ã®æœ«å°¾ï¼‰
    try:
        ticker = exchange.fetch_ticker(pair)
        latest_price = ticker.get('last') if isinstance(ticker, dict) else None
        if latest_price is None:
            print("ã‚¨ãƒ©ãƒ¼: ä¾¡æ ¼ãŒå–å¾—ã§ãã¾ã›ã‚“ã§ã—ãŸã€‚")
            return
        print(f"ğŸ’µ æœ€æ–°ã®å¸‚å ´ä¾¡æ ¼: {latest_price} å††")

        # 3. æ³¨æ–‡æ•°é‡ã‚’è¨ˆç®— (äºˆç®— Ã· ä¾¡æ ¼)
        buy_amount_raw = JAPANESE_YEN_BUDGET / latest_price
        decimals = int(-math.log10(MIN_ORDER_BTC)) if MIN_ORDER_BTC < 1 else 0
        buy_amount = math.floor(buy_amount_raw * (10**decimals)) / (10**decimals)
        order_cost = buy_amount * latest_price

        # æ³¨æ–‡å‰ãƒã‚§ãƒƒã‚¯
        if buy_amount < MIN_ORDER_BTC:
            print(f"â„¹ï¸ æ³¨æ–‡æ•°é‡ãŒæœ€å°å–å¼•å˜ä½ã‚’ä¸‹å›ã£ã¦ã„ã¾ã™: {buy_amount} BTC (æœ€å°: {MIN_ORDER_BTC} BTC)")
            return

        print(f"âœ… æ³¨æ–‡å¯èƒ½: {buy_amount} BTC (ç´„ {order_cost:.2f} å††)")

    except Exception as e:
        print(f"ã‚¨ãƒ©ãƒ¼: æœ€æ–°ä¾¡æ ¼ã®å–å¾—ã«å¤±æ•—ã—ã¾ã—ãŸã€‚Botã‚’åœæ­¢ã—ã¾ã™: {e}")
        return
    # ä¾‹: 0.005 BTC ãªã©ã®æœ‰åŠ¹æ¡æ•°ã§åˆ‡ã‚Šæ¨ã¦ã¾ã™ã€‚
    # æœ€å°å–å¼•å˜ä½ã®æ¡æ•°ã«åˆã‚ã›ã¦åˆ‡ã‚Šæ¨ã¦ã‚‹ (0.001ã®å ´åˆã¯å°æ•°ç‚¹ä»¥ä¸‹3æ¡)
    # math.floorã§ã€å°æ•°ç‚¹ä»¥ä¸‹4æ¡ç›®ã¾ã§ã§åˆ‡ã‚Šæ¨ã¦ã‚’å®Ÿè¡Œã—ã¾ã™ã€‚  print(f"ã‚¨ãƒ©ãƒ¼: æœ€æ–°ä¾¡æ ¼ã®å–å¾—ã«å¤±æ•—ã—ã¾ã—ãŸã€‚Botã‚’åœæ­¢ã—ã¾ã™: {e}")
    
    # 4. ï¼ˆè£œè¶³ï¼‰æœ€å°æ³¨æ–‡å˜ä½ã«ã‚ˆã‚‹ä¸¸ã‚ï¼ˆç‰¹æ®Šã‚±ãƒ¼ã‚¹ï¼‰
    if decimals == 0 and MIN_ORDER_BTC == 0.0001:
        buy_amount = math.floor(buy_amount_raw * 10000) / 10000
        MIN_ORDER_BTC = 0.0001
        print("â„¹ï¸ æœ€å°æ³¨æ–‡æ•°é‡ã‚’ 0.0001 BTC ã«ä¿®æ­£ã—ã€æ³¨æ–‡æ•°é‡ã‚’èª¿æ•´ã—ã¾ã—ãŸã€‚")

    print(f"ğŸ§® æ³¨æ–‡æ•°é‡: {buy_amount} BTC")
    # æ³¨: å®Ÿéš›ã«å–å¼•ã‚’ç™ºè¡Œã™ã‚‹å ´åˆã¯ execute_order ã‚’å‘¼ã¶ã‹ã€æ˜ç¤ºçš„ã« order ã‚’ä½œæˆã—ã¦ãã ã•ã„ã€‚
    # ã“ã“ã§ã¯ä¾‹ã¨ã—ã¦ FundManager ã«ã‚ˆã‚‹è³‡é‡‘ç®¡ç†å‡¦ç†ã‚’è©¦è¡Œã—ã€ä¾‹å¤–ã‚’ã‚­ãƒ£ãƒƒãƒã—ã¾ã™ã€‚
    try:
        # å®Ÿæ³¨æ–‡ã‚’è¡Œã†å ´åˆã®ã‚µãƒ³ãƒ—ãƒ«ï¼ˆã‚³ãƒ¡ãƒ³ãƒˆã‚¢ã‚¦ãƒˆï¼‰:
        # order = execute_order(exchange, pair, 'buy', buy_amount)
        # ä»Šå›ã¯ã‚·ãƒŸãƒ¥ãƒ¬ãƒ¼ã‚·ãƒ§ãƒ³ç”¨ã®ãƒ€ãƒŸãƒ¼æ³¨æ–‡æƒ…å ±ã‚’ä½œæˆã—ã¾ã™
        order = {'id': 'simulated_order', 'amount': buy_amount, 'cost': order_cost}

        # FundManager ã«æ®‹é«˜æ¶ˆè²»ã‚’é€šçŸ¥ï¼ˆå®Ÿè£…ã«ä¾å­˜ï¼‰
        if hasattr(fund_manager, "place_order"):
            fund_manager.place_order(order_cost)

        print(f"ğŸ’° æ³¨æ–‡å¾Œã®æ®‹é«˜: {fund_manager.available_fund():.2f} å††")
    
        print("âœ… æ³¨æ–‡ãŒæ­£å¸¸ã«å®Œäº†ã—ã¾ã—ãŸã€‚")
    except Exception as e:
        print(f"âš ï¸ æ³¨æ–‡ã«å¤±æ•—ã—ã¾ã—ãŸ: {e}")

    # æ³¨æ–‡å¾Œã«å…±é€šã§å®Ÿè¡Œã—ãŸã„å‡¦ç†ï¼ˆæˆåŠŸã§ã‚‚å¤±æ•—ã§ã‚‚ï¼‰ 
    # æ¬¡ã®ãƒ«ãƒ¼ãƒ—ã§æ³¨æ–‡ã‚’ç¶™ç¶šã™ã‚‹ã‹ã©ã†ã‹ã®ã‚·ãƒŸãƒ¥ãƒ¬ãƒ¼ã‚·ãƒ§ãƒ³ãƒã‚§ãƒƒã‚¯ã‚’è¡Œã† 
    required_cost = buy_amount * latest_price
    try: 
        if hasattr(fund_manager, "available_fund"):
            available = fund_manager.available_fund() if hasattr(fund_manager, "available_fund") else None
            if available is not None and available < required_cost:
                print(f"ğŸš«  æ®‹é«˜ä¸è¶³ã®ãŸã‚æ³¨æ–‡ã‚’ã‚¹ã‚­ãƒƒãƒ—ã—ã¾ã™ï¼ˆå¿…è¦: {required_cost:.2f} å††, æ®‹é«˜: {available:.2f} å††ï¼‰")
            elif available is not None:
                print(f"âœ… æ¬¡ã®æ³¨æ–‡ã‚’å®Ÿè¡Œå¯èƒ½: ï¼ˆå¿…è¦: {required_cost:.2f} å††, æ®‹é«˜: {available:.2f} å††ï¼‰")
        # FundManagerãŒãªã„å ´åˆã®ãƒ­ã‚°ã¯ã€ä¸Šè¨˜ifæ–‡ã®å¤–å´ã«ç§»å‹•ã¾ãŸã¯å‰Šé™¤ã‚’æ¨å¥¨
        else:
            # å¤±æ•—ã—ãŸå ´åˆ: FundManagerã®ã‚¬ãƒ¼ãƒ‰æ©Ÿèƒ½ï¼ˆæ®‹é«˜ä¸è¶³ï¼‰ãŒç™ºå‹•
            available = fund_manager.available_fund()
            # print(f"ğŸš« äºˆç®—ä¸è¶³ã®ãŸã‚æ³¨æ–‡ã‚’ã‚¹ã‚­ãƒƒãƒ—ã—ã¾ã™ï¼ˆå¿…è¦: {order_cost:.2f} å††, æ®‹é«˜: {available:.2f} å††ï¼‰")
            
    except Exception as e:
        print(f"ğŸš«  æ®‹é«˜ãƒã‚§ãƒƒã‚¯ä¸­ã«ã‚¨ãƒ©ãƒ¼ãŒç™ºç”Ÿã—ã¾ã—ãŸ: {e}")

    # ã“ã®ãƒ–ãƒ­ãƒƒã‚¯ã¯ place_order ã®åˆ¤å®šã§ä»£ç”¨ã§ãã¾ã™ã€‚
    return # ãƒ«ãƒ¼ãƒ—å‡¦ç†ã¯å¤–å´ã® if __name__ == "__main__": ã§ç¶™ç¶š


# Botã‚’å®Ÿè¡Œ
if __name__ == "__main__":
    print("ğŸ” è‡ªå‹•å£²è²·Botã‚’ç¶™ç¶šé‹ç”¨ãƒ¢ãƒ¼ãƒ‰ã§èµ·å‹•ã—ã¾ã™")
    exchange = connect_to_bitbank()
    # åˆæœŸè³‡é‡‘ã¯ env ã§è¨­å®šå¯èƒ½ï¼ˆãªã‘ã‚Œã° 20000 å††ï¼‰
    initial_fund = float(os.getenv('INITIAL_FUND', '20000'))
    fund_manager = FundManager(initial_fund=initial_fund)
    # æ¯ãƒ«ãƒ¼ãƒ—ã§è‡ªå‹•æŠ•å…¥ã™ã‚‹å°‘é¡ï¼ˆä¾‹: æ¯æ™‚é–“100å††ãšã¤å…¥é‡‘ã™ã‚‹ï¼‰ã‚’ç’°å¢ƒå¤‰æ•°ã§æŒ‡å®š
    deposit_amount = float(os.getenv('DEPOSIT_AMOUNT', '0'))
    if not exchange:
        print("APIæ¥ç¶šã«å¤±æ•—ã—ãŸãŸã‚Botã‚’çµ‚äº†ã—ã¾ã™ã€‚")
    else:
        while True:
            run_bot(exchange, fund_manager)
            if deposit_amount and deposit_amount > 0:
                fund_manager.add_funds(deposit_amount)
                print(f"ğŸ’³ è‡ªå‹•å…¥é‡‘: {deposit_amount:.2f} å†† â†’ æ®‹é«˜: {fund_manager.available_fund():.2f} å††")
            time.sleep(3600)  # 1æ™‚é–“å¾…æ©Ÿ
